name: Deploy Backend

on:
  workflow_dispatch: # Manual trigger
  repository_dispatch: # Event from tserver repository
    types: [deploy-backend]

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    env:
      # Database Configuration
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      # Server Configuration
      SERVER_PORT: ${{ secrets.SERVER_PORT }}
      # JWT Configuration
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      JWT_ACCESS_TOKEN_EXPIRES_IN: ${{ secrets.JWT_ACCESS_TOKEN_EXPIRES_IN }}
      JWT_REFRESH_TOKEN_EXPIRES_IN: ${{ secrets.JWT_REFRESH_TOKEN_EXPIRES_IN }}
      NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
      # S3 Configuration
      S3_ACCESS_KEY_ID: ${{ secrets.S3_ACCESS_KEY_ID }}
      S3_SECRET_ACCESS_KEY: ${{ secrets.S3_SECRET_ACCESS_KEY }}
      S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
      S3_ENDPOINT: ${{ secrets.S3_ENDPOINT }}
      S3_PUBLIC_DOMAIN: ${{ secrets.S3_PUBLIC_DOMAIN }}
      # CORS Configuration
      ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }}
      # Mail Configuration
      MAIL_HOST: ${{ secrets.MAIL_HOST }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_LOGIN: ${{ secrets.MAIL_LOGIN }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}

    steps:
      - name: Get backend image info
        id: image-info
        run: |
          # Get information about new image from payload
          BACKEND_IMAGE="${{ github.event.client_payload.backend_image }}"
          echo "backend_image=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          echo "ðŸš€ Deploying backend image: $BACKEND_IMAGE"

      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "ðŸš€ Deploying updated backend..."

            cd /root/tattoo-app

            # Create .env file with all required variables
            echo "ðŸ”§ Creating .env file from GitHub Secrets..."
            cat > .env << 'EOF'
            # Database Configuration
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB }}
            DATABASE_URL=${{ secrets.DATABASE_URL }}
            # Server Configuration
            NODE_ENV=production
            SERVER_PORT=${{ secrets.SERVER_PORT }}
            # JWT Configuration
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_ACCESS_TOKEN_EXPIRES_IN=${{ secrets.JWT_ACCESS_TOKEN_EXPIRES_IN }}
            JWT_REFRESH_TOKEN_EXPIRES_IN=${{ secrets.JWT_REFRESH_TOKEN_EXPIRES_IN }}
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            # S3 Configuration
            S3_ACCESS_KEY_ID=${{ secrets.S3_ACCESS_KEY_ID }}
            S3_SECRET_ACCESS_KEY=${{ secrets.S3_SECRET_ACCESS_KEY }}
            S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
            S3_ENDPOINT=${{ secrets.S3_ENDPOINT }}
            S3_PUBLIC_DOMAIN=${{ secrets.S3_PUBLIC_DOMAIN }}
            # CORS Configuration
            ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}
            # Mail Configuration
            MAIL_HOST=${{ secrets.MAIL_HOST }}
            MAIL_PORT=${{ secrets.MAIL_PORT }}
            MAIL_LOGIN=${{ secrets.MAIL_LOGIN }}
            MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}
            EOF

            # Force stop and remove backend container
            echo "â¹ï¸ Force stopping and removing backend container..."
            docker-compose -f docker-compose.prod.yml down backend
            docker rm -f tattoo-backend-prod || true

            # Remove old image (force)
            echo "ðŸ—‘ï¸ Force removing old backend image..."
            docker rmi -f mip92/tattoo-server:latest || true

            # Clean up unused images
            echo "ðŸ§¹ Cleaning up unused images..."
            docker image prune -f

            # Ensure postgres is running first
            echo "ðŸ” Checking postgres status..."
            docker-compose -f docker-compose.prod.yml up -d postgres
            sleep 10

            # Start backend with new image
            echo "ðŸ”„ Starting backend with new image..."
            docker-compose -f docker-compose.prod.yml up -d backend

            # Wait for backend to start
            echo "â³ Waiting for backend to start..."
            sleep 15

            # Check if backend started successfully
            echo "ðŸ” Checking backend startup..."
            if ! docker ps | grep -q tattoo-backend-prod; then
                echo "âŒ Backend failed to start, trying to restart..."
                docker-compose -f docker-compose.prod.yml restart backend
                sleep 15
            fi

            # Restart nginx to pick up any configuration changes
            echo "ðŸ”„ Restarting nginx..."
            docker-compose -f docker-compose.prod.yml restart nginx
            sleep 5

            # Wait for initialization
            echo "â³ Waiting for backend to initialize..."
            sleep 30

            # Check status
            echo "ðŸ“Š Checking backend status..."
            docker ps | grep backend

            # Check that new image is being used
            echo "ðŸ” Checking image hash..."
            docker inspect mip92/tattoo-server:latest --format='{{.Id}}' || echo "New image not found"

            # Check health check
            echo "ðŸ’š Checking backend health..."
            docker-compose -f docker-compose.prod.yml ps | grep backend

            # Check backend container status
            echo "ðŸ“Š Checking backend container status..."
            docker ps -a | grep backend || echo "No backend container found"

            # Check backend logs for errors
            echo "ðŸ“‹ Checking backend logs for errors..."
            docker logs tattoo-backend-prod --tail 100 || echo "Could not get logs"

            # Check if backend container is running
            echo "ðŸ” Checking if backend container is running..."
            if docker ps | grep -q tattoo-backend-prod; then
                echo "âœ… Backend container is running"
            else
                echo "âŒ Backend container is not running"
                echo "ðŸ“‹ Container status:"
                docker ps -a | grep backend
            fi

            # Check backend port binding
            echo "ðŸ” Checking backend port binding..."
            docker port tattoo-backend-prod || echo "No port binding found"

            # Wait a bit more for health check to pass
            echo "â³ Waiting for health check to pass..."
            sleep 20

            # Test backend endpoint directly
            echo "ðŸ” Testing backend endpoint directly..."
            curl -f http://localhost:3000/health || echo "Backend health endpoint not responding"

            # Check if backend is responding on internal network
            echo "ðŸ” Testing backend from nginx container..."
            docker exec tattoo-nginx-prod curl -f http://backend:3000/health || echo "Backend not accessible from nginx"

            echo "âœ… Backend deployment completed!"

      - name: Health check backend
        run: |
          echo "ðŸ” Testing backend health..."
          sleep 20

          # Test health endpoint first (most reliable)
          echo "Testing health endpoint..."
          HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SERVER_IP }}/health || echo "000")
          echo "Health response: $HEALTH_RESPONSE"

          # Test GraphQL endpoint with timeout
          echo "Testing GraphQL endpoint..."
          GRAPHQL_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 http://${{ secrets.SERVER_IP }}/graphql || echo "000")
          echo "GraphQL response: $GRAPHQL_RESPONSE"

          # Test direct backend port (bypass nginx)
          echo "Testing direct backend port..."
          DIRECT_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://${{ secrets.SERVER_IP }}:3000/health || echo "000")
          echo "Direct backend response: $DIRECT_RESPONSE"

          # Check nginx status
          echo "Checking nginx status..."
          NGINX_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SERVER_IP }}/ || echo "000")
          echo "Nginx main page response: $NGINX_RESPONSE"

          # Proper health check logic
          if [ "$HEALTH_RESPONSE" = "200" ]; then
            echo "âœ… Backend health endpoint is working"
            
            # Check if GraphQL is working (main functionality)
            if [ "$GRAPHQL_RESPONSE" = "400" ] || [ "$GRAPHQL_RESPONSE" = "200" ]; then
              echo "âœ… GraphQL endpoint is working (HTTP $GRAPHQL_RESPONSE)"
            elif [ "$GRAPHQL_RESPONSE" = "504" ]; then
              echo "âš ï¸ GraphQL endpoint timeout (504) - possible nginx/proxy issue"
            else
              echo "âŒ GraphQL endpoint not working (HTTP $GRAPHQL_RESPONSE)"
            fi
            
            # Check direct backend access
            if [ "$DIRECT_RESPONSE" = "200" ]; then
              echo "âœ… Direct backend access working"
            else
              echo "âš ï¸ Direct backend access not working (HTTP $DIRECT_RESPONSE)"
            fi
            
            echo "âœ… Backend deployment successful"
          else
            echo "âŒ Backend health check failed"
            echo "Health: $HEALTH_RESPONSE, GraphQL: $GRAPHQL_RESPONSE, Direct: $DIRECT_RESPONSE, Nginx: $NGINX_RESPONSE"
            exit 1
          fi
